# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_mdd.ipynb.

# %% auto 0
__all__ = ['MDDNodeState', 'MDDArcLabel', 'DEFAULT_MDD_NAME', 'MDDNode', 'MDDArc', 'MDDNodeData', 'MDDArcData', 'MDD']

# %% ../nbs/00_mdd.ipynb 3
from collections.abc import Callable, Collection, Hashable, ItemsView, Iterable, Iterator, KeysView, Mapping
from itertools import chain
from dataclasses import dataclass, field
from typing import Optional

# %% ../nbs/00_mdd.ipynb 7
MDDNodeState = Hashable

@dataclass(frozen=True)
class MDDNode:
    """MDDNode represents a single node in the MDD.

    An MDDNode is uniquely identified by its layer and state. The (node) state
    must be a `collections.abc.Hashable` object.

    Parameters
    ----------
    layer : int
        layer the node is in
    state : MDDNodeState
        state associated with node

    """
    layer: int
    state: MDDNodeState

    def __str__(self) -> str:
        return f"N_{self.layer}({self.state})"

# %% ../nbs/00_mdd.ipynb 10
MDDArcLabel = Hashable

@dataclass(frozen=True)
class MDDArc:
    """MDDArc represents a single arc in the MDD.

    An MDDArc is uniquely identified by its head node, tail node, and label.
    The (arc) label must be a `collections.abc.Hashable` object.

    Parameters
    ----------
    label : MDDArcLabel
        label of arc (e.g., assigned value)
    tail : MDDNode
        tail/source node
    head : MDDNode
        head/destination node

    """
    label: MDDArcLabel
    tail: MDDNode
    head: MDDNode

    def __str__(self) -> str:
        return f"A({self.label}:{self.tail},{self.head})"

# %% ../nbs/00_mdd.ipynb 13
@dataclass()
class MDDNodeData:
    """MDDNodeData represents information associated with an `MDDNode`.

    Parameters
    ----------
    incoming : list[MDDArc]
        list of incoming arcs (default: [])
    outgoing : list[MDDArc]
        list of outgoing arcs (default: [])

    """
    incoming: list[MDDArc] = field(default_factory=list)
    outgoing: list[MDDArc] = field(default_factory=list)

    def __str__(self) -> str:
        incoming_str = ", ".join(str(a) for a in self.incoming)
        outgoing_str = ", ".join(str(a) for a in self.outgoing)
        return f"<in=[{incoming_str}], out=[{outgoing_str}]>"

# %% ../nbs/00_mdd.ipynb 16
@dataclass()
class MDDArcData:
    """MDDArcData represents information associated with an `MDDArc`.

    Parameters
    ----------
    weight : float
        weight of arc (default: 0.0)

    """
    weight: float = 0.0

    def __str__(self) -> str:
        return f"<{self.weight}>"

# %% ../nbs/00_mdd.ipynb 17
DEFAULT_MDD_NAME = "mdd"

@dataclass()
class MDD:
    """MDD represents a multivalued decision diagram.

    Parameters
    ----------
    name : str
        name of MDD (default: 'mdd')
    nodes : list[dict[MDDNode, MDDNodeData]]
        nodes of MDD (default: [])
    arcs : dict[MDDArc, MDDArcData]
        arcs of MDD (default: dict())

    """
    name: str = DEFAULT_MDD_NAME
    nodes: list[dict[MDDNode, MDDNodeData]] = field(default_factory=list)
    arcs: dict[MDDArc, MDDArcData] = field(default_factory=dict)

    @property
    def num_node_layers(self) -> int:
        """Number of node layers; equal to number of 'variables' + 1.

        Class property: `int`
        """
        return len(self.nodes)

    @property
    def num_arc_layers(self) -> int:
        """Number of arc layers; equal to number of 'variables'.

        Class property: `int`
        """
        return len(self.nodes) - 1

    @property
    def width_list(self) -> list[int]:
        """Number of nodes in each layer.

        Class property: `list`[`int`]
        """
        return [len(layer) for layer in self.nodes]

    @property
    def max_width(self) -> int:
        """Maximum number of nodes in a single node layer.

        Class property: `int`
        """
        return max(len(layer) for layer in self.nodes)

    def all_nodes(self) -> Iterator[MDDNode]:
        """Iterate over all nodes in the MDD.

        Returns: `collections.abc.Iterator`[`MDDNode`]
        """
        return chain.from_iterable(l.keys() for l in self.nodes)

    def all_nodeitems_in_layer(
        self,
        layer: int, # index of layer
    ) -> ItemsView[MDDNode, MDDNodeData]: # `collections.abc.ItemsView`[`MDDNode`, `MDDNodeData`]
        """A view of all nodes and their associated data in a layer."""
        return self.nodes[layer].items()

    def allnodes_in_layer(
        self,
        layer: int, # index of layer
    ) -> KeysView[MDDNode]: # `collections.abc.KeysView`[`MDDNode`]
        """Return a view of all nodes in a layer."""
        return self.nodes[layer]

    def all_outgoing_arcs(self) -> Iterator[MDDArc]:
        """Iterate over all outgoing arcs in the MDD.

        Returns: `collections.abc.Iterator`[`MDDArc`]
        """
        return chain.from_iterable(ui.outgoing for j in range(self.num_arc_layers) for ui in self.nodes[j].values())

    def all_incoming_arcs(self) -> Iterator[MDDArc]:
        """Iterate over all incoming arcs in the MDD.

        Returns: `collections.abc.Iterator`[`MDDArc`]
        """
        return chain.from_iterable(ui.incoming for j in range(self.num_arc_layers) for ui in self.nodes[j+1].values())

    def __str__(
        self,
        show_long: bool = False, # use more vertical space (default: False)
        show_incoming: bool = False, # show incoming arcs (default: False)
    ) -> str:
        """Return a (human-readable) string representation of the MDD."""
        s = f"== MDD ({self.name}, {self.num_arc_layers} layers) ==\n"
        if show_long:
            # Long form
            s += "# Nodes\n"
            for (j, lyr) in enumerate(self.nodes):
                s += f"L{j}:\n"
                for v in lyr:
                    s += f"\t{v}: <"
                    s += "in={" + ", ".join(str(a) for a in self.nodes[j][v].incoming) + "}, "
                    s += "out={" + ", ".join(str(a) for a in self.nodes[j][v].outgoing) + "}"
                    s += ">\n"
            s += "# (Outgoing) Arcs\n"
            s += "\n".join(f"{a}:{self.arcs[a]}" for a in self.all_outgoing_arcs())
            if show_incoming:
                s += "\n# (Incoming) Arcs\n"
                s += "\n".join(f"{a}:{self.arcs[a]}" for a in self.all_incoming_arcs())
        else:
            # Short form
            s += "# Nodes\n"
            for (j, lyr) in enumerate(self.nodes):
                s += f"L{j}: "
                s += ", ".join(str(v) for v in self.allnodes_in_layer(j)) + "\n"
            s += "# (Outgoing) Arcs\n"
            s += ", ".join(f"{a}:{self.arcs[a]}" for a in self.all_outgoing_arcs())
            if show_incoming:
                s += "\n# (Incoming) Arcs\n"
                s += ", ".join(f"{a}:{self.arcs[a]}" for a in self.all_incoming_arcs())
        return s

    def clear(self) -> None:
        """Reset the MDD.

        Returns: None
        """
        self.nodes = []

    def append_new_layers(
        self,
        n: int = 1 # number of layers to append
    ) -> None:
        """Append new layers to the MDD."""
        self.nodes.extend([dict() for _ in range(n)])

    def get_node_data(
        self,
        node: MDDNode, # node in MDD
    ) -> MDDNodeData:
        """Get `MDDNodeData` corresponding to `node`.

        Note this function can NOT be used to populate the underlying
        dictionary; it can only be used to reference the object.

        In general, you should use `MDD.all_nodeitems_in_layer` if you
        want to update node data in a systematic manner. The author
        recommends only using this function if `MDD.all_nodeitems_in_layer`
        cannot be used.
        """
        return self.nodes[node.layer][node]

    def add_arc(
        self,
        newarc: MDDArc, # arc to be added
        newarc_data: MDDArcData, # data for arc to be added
    ) -> None:
        """Add an arc to the MDD, without any sanity checks.

        The head and tail nodes of the arc should already exist in the MDD.
        """
        self.get_node_data(newarc.tail).outgoing.append(newarc)
        self.get_node_data(newarc.head).incoming.append(newarc)
        self.arcs[newarc] = newarc_data

    def add_arcs(
        self,
        newarcs: Mapping[MDDArc, MDDArcData], # arcs and their data to be added
    ) -> None:
        """Add arcs to the MDD, without any sanity checks."""
        for arc, arc_data in newarcs.items():
            self.add_arc(arc, arc_data)

    def remove_arc(
        self,
        rmvarc: MDDArc, # arc to be removed
    ) -> None:
        """Remove an arc from the MDD, without any sanity checks."""
        self.get_node_data(rmvarc.tail).outgoing.remove(rmvarc)
        self.get_node_data(rmvarc.head).incoming.remove(rmvarc)
        del self.arcs[rmvarc]

    def remove_arcs(
        self,
        rmvarcs: Iterable[MDDArc], # arcs to be removed
    ) -> None:
        """Remove arcs from the MDD, without any sanity checks."""
        for arc in rmvarcs:
            self.remove_arc(arc)

    def add_node(
        self,
        newnode: MDDNode, # node to be added
    ) -> None:
        """Add a node to the MDD, without any sanity checks.

        The node's layer should already exist in the MDD.

        NOTE: If an identical node already exists, its incoming and outgoing
        arcs will be ERASED!!!
        """
        self.nodes[newnode.layer][newnode] = MDDNodeData()

    def add_nodes(
        self,
        newnodes: Iterable[MDDNode], # nodes to be added
    ) -> None:
        """Add nodes to the MDD, without any sanity checks."""
        for node in newnodes:
            self.add_node(node)

    def remove_node(
        self,
        rmvnode: MDDNode, # node to be removed
    ) -> None:
        """Remove a node from the MDD, without any sanity checks."""
        for arc in self.get_node_data(rmvnode).incoming:
            self.get_node_data(arc.tail).outgoing.remove(arc)
        for arc in self.get_node_data(rmvnode).outgoing:
            self.get_node_data(arc.head).incoming.remove(arc)
        del self.nodes[rmvnode.layer][rmvnode]

    def remove_nodes(
        self,
        rmvnodes: Iterable[MDDNode], # nodes to be removed
    ) -> None:
        """Remove nodes from the MDD, without any sanity checks."""
        for node in rmvnodes:
            self.remove_node(node)

    @staticmethod
    def _default_adfun(d: MDDArcData, ns: MDDNodeState, nt: MDDNodeState, j: int) -> MDDArcData:
        """By default, use the original arc data."""
        return d

    def merge_nodes(
        self,
        mnodes: Collection[MDDNode],
        mlayer: int,
        nsfun: Callable[[Collection[MDDNodeState], int], MDDNodeState],
        adinfun: Optional[Callable[[MDDArcData, MDDNodeState, MDDNodeState, int], MDDArcData]] = None,
        adoutfun: Optional[Callable[[MDDArcData, MDDNodeState, MDDNodeState, int], MDDArcData]] = None,
    ) -> MDDNode:
        """Merge specified nodes into a new supernode, and modify arcs appropriately.

        NOTE: All nodes to be merged must be located on the same layer.

        Parameters
        ----------
        mnodes : Collection[MDDNode]
            nodes to be merged together
        mlayer : int
            layer containing all nodes to be merged
        nsfun : Callable[[Collection[MDDNodeState], int], MDDNodeState]
            function that determines the node state of the new merged supernode
        adinfun : Optional[Callable[[MDDArcData, MDDNodeState, MDDNodeState, int], MDDArcData]]
            function that determines the arc data of all arcs incoming to the new merged supernode;
            if adinfun is None (default), the original arc data is used
        adoutfun : Optional[Callable[[MDDArcData, MDDNodeState, MDDNodeState, int], MDDArcData]]
            function that determines the arc data of all arcs outgoing from the new merged supernode;
            if adoutfun is None (default), the original arc data is used

        Returns
        -------
        MDDNode
            new merged supernode
        """
        if adinfun is None:
            adinfun = self._default_adfun
        if adoutfun is None:
            adoutfun = self._default_adfun

        # Create new supernode, and new incoming / outgoing arcs
        mState = nsfun([v.state for v in mnodes], mlayer)
        mNode = MDDNode(mlayer, mState)

        newIncoming = dict()
        newOutgoing = dict()
        for v in mnodes:
            node_data = self.get_node_data(v)
            for inarc in node_data.incoming:
                new_inarc = MDDArc(inarc.label, inarc.tail, mNode)
                new_inarc_data = adinfun(self.arcs[inarc], inarc.head.state, mState, mlayer)
                newIncoming[new_inarc] = new_inarc_data
            for outarc in node_data.outgoing:
                new_outarc = MDDArc(outarc.label, mNode, outarc.head)
                new_outarc_data = adoutfun(self.arcs[outarc], outarc.tail.state, mState, mlayer)
                newOutgoing[new_outarc] = new_outarc_data

        # Delete merged nodes
        for v in mnodes:
            self.remove_node(v)

        # Add supernode and its arcs to MDD
        self.add_node(mNode)
        self.add_arcs(newIncoming)
        self.add_arcs(newOutgoing)

        # Return new merged supernode
        return mNode
