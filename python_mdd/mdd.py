# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_mdd.ipynb.

# %% auto 0
__all__ = ['MDDNodeState', 'MDDArcLabel', 'MDDNode', 'MDDArc', 'MDDNodeInfo', 'MDD']

# %% ../nbs/00_mdd.ipynb 3
from collections.abc import Callable, Collection, Hashable, ItemsView, Iterable, Iterator, KeysView
from itertools import chain
from dataclasses import dataclass, field

# %% ../nbs/00_mdd.ipynb 5
MDDNodeState = Hashable

@dataclass(frozen=True)
class MDDNode:
    """MDDNode represents a single node in the MDD.

    An MDDNode is uniquely identified by its layer and state. The (node) state
    must be a `collections.abc.Hashable` object.

    Parameters
    ----------
    layer : int
        layer the node is in
    state : MDDNodeState
        state associated with node

    """
    layer: int
    state: MDDNodeState

    def __str__(self) -> str:
        return f"N_{self.layer}({self.state})"

# %% ../nbs/00_mdd.ipynb 8
MDDArcLabel = Hashable

@dataclass()
class MDDArc:
    """MDDArc represents a single arc in the MDD.

    An MDDArc is uniquely identified by its head/tail nodes, label, and weight.
    The (arc) label must be a `collections.abc.Hashable` object.

    Parameters
    ----------
    label : MDDArcLabel
        label of arc (e.g., assigned value)
    weight : float
        weight of arc (e.g., coefficient)
    tail : MDDNode
        tail/source node
    head : MDDNode
        head/destination node

    """
    label: MDDArcLabel
    weight: float
    tail: MDDNode
    head: MDDNode

    def __str__(self) -> str:
        return f"A({self.label},{self.weight}:{self.tail},{self.head})"

# %% ../nbs/00_mdd.ipynb 11
@dataclass()
class MDDNodeInfo:
    """MDDNodeInfo represents information associated with an MDDNode.

    Parameters
    ----------
    incoming : list[MDDArc]
        list of incoming arcs (default: [])
    outgoing : list[MDDArc]
        list of outgoing arcs (default: [])

    """
    incoming: list[MDDArc] = field(default_factory=list)
    outgoing: list[MDDArc] = field(default_factory=list)

    def __str__(self) -> str:
        incoming_str = ", ".join(str(a) for a in self.incoming)
        outgoing_str = ", ".join(str(a) for a in self.outgoing)
        return f"<in=[{incoming_str}], out=[{outgoing_str}]>"

# %% ../nbs/00_mdd.ipynb 14
@dataclass()
class MDD:
    """MDD represents a multivalued decision diagram, or MDD.

    Parameters
    ----------
    name : str
        name of MDD (default: 'mdd')
    nodes : list[dict[MDDNode, MDDNodeInfo]]
        nodes of MDD (default: [])

    """
    name: str = "mdd"
    nodes: list[dict[MDDNode, MDDNodeInfo]] = field(default_factory=list)

    @property
    def numNodeLayers(self) -> int:
        """Number of node layers; equal to number of 'variables' + 1."""
        return len(self.nodes)

    @property
    def numArcLayers(self) -> int:
        """Number of arc layers; equal to number of 'variables'."""
        return len(self.nodes) - 1

    @property
    def widthList(self) -> list[int]:
        """Number of nodes in each layer."""
        return [len(layer) for layer in self.nodes]

    @property
    def maxWidth(self) -> int:
        """Maximum number of nodes in a single node layer."""
        return max(len(layer) for layer in self.nodes)

    def allnodes(self) -> Iterator[MDDNode]:
        """Iterate over all MDDNodes in the MDD."""
        return chain.from_iterable(l.keys() for l in self.nodes)

    def allnodeitems_in_layer(
        self,
        layer: int, # index of layer
    ) -> ItemsView[MDDNode, MDDNodeInfo]:
        """Return a view of all (MDDNode, MDDNodeInfo) pairs in a layer."""
        return self.nodes[layer].items()

    def allnodes_in_layer(
        self,
        layer: int, # index of layer
    ) -> KeysView[MDDNode]:
        """Return a view of all MDDNodes in a layer."""
        return self.nodes[layer]

    def alloutgoingarcs(self) -> Iterator[MDDArc]:
        """Iterate over all outgoing arcs in the MDD."""
        return chain.from_iterable(ui.outgoing for j in range(self.numArcLayers) for ui in self.nodes[j].values())

    def allincomingarcs(self) -> Iterator[MDDArc]:
        """Iterate over all incoming arcs in the MDD."""
        return chain.from_iterable(ui.incoming for j in range(self.numArcLayers) for ui in self.nodes[j+1].values())

    def __str__(
        self,
        showLong: bool = False, # use more vertical space (default: False)
        showIncoming: bool = False, # show incoming arcs (default: False)
    ) -> str:
        """Return a (human-readable) string representation of the MDD."""
        s = '== MDD (' + self.name + ', ' + str(self.numArcLayers) + ' layers) ==\n'
        if showLong:
            # Long form
            s += '# Nodes\n'
            for (j, lyr) in enumerate(self.nodes):
                s += 'L' + str(j) + ':\n'
                for v in lyr:
                    s += '\t' + str(v) + ': <'
                    s += 'in={' + ', '.join(str(a) for a in self.nodes[j][v].incoming) + '}, '
                    s += 'out={' + ', '.join(str(a) for a in self.nodes[j][v].outgoing) + '}'
                    s += '>\n'
            s += '# (Outgoing) Arcs\n'
            s += '\n'.join(str(a) for a in self.alloutgoingarcs())
            if showIncoming:
                s += '\n# (Incoming) Arcs\n'
                s += '\n'.join(str(a) for a in self.allincomingarcs())
        else:
            # Short form
            s += '# Nodes\n'
            for (j, lyr) in enumerate(self.nodes):
                s += 'L' + str(j) + ': '
                s += ', '.join(str(v) for v in self.allnodes_in_layer(j)) + '\n'
            s += '# (Outgoing) Arcs\n'
            s += ', '.join(str(a) for a in self.alloutgoingarcs())
            if showIncoming:
                s += '\n# (Incoming) Arcs\n'
                s += ', '.join(str(a) for a in self.allincomingarcs())
        return s

# %% ../nbs/00_mdd.ipynb 17
@patch
def clear(self: MDD) -> None:
    """Reset the MDD."""
    self.nodes = []

# %% ../nbs/00_mdd.ipynb 18
@patch
def append_new_layers(
    self: MDD,
    n: int = 1 # number of layers to append
) -> None:
    """Append new layers to the MDD."""
    self.nodes.extend([dict() for _ in range(n)])

# %% ../nbs/00_mdd.ipynb 19
@patch
def get_node_info(
    self: MDD,
    node: MDDNode, # node in MDD
) -> MDDNodeInfo:
    """Get `MDDNodeInfo` corresponding to `node`.

    Note this function can NOT be used to populate the underlying
    dictionary; it can only be used to reference the object.

    In general, you should use allnodeitems_in_layer(...) if you
    want to update node info in a systematic manner. The author
    recommends only using this function if allnodeitems_in_layer(...)
    cannot be used.
    """
    return self.nodes[node.layer][node]

# %% ../nbs/00_mdd.ipynb 20
@patch
def add_arc(
    self: MDD,
    newarc: MDDArc, # arc to be added
) -> None:
    """Add an arc to the MDD, without any sanity checks.

    The head and tail nodes of the arc should already exist in the MDD.
    """
    self.get_node_info(newarc.tail).outgoing.append(newarc)
    self.get_node_info(newarc.head).incoming.append(newarc)

# %% ../nbs/00_mdd.ipynb 21
@patch
def add_arcs(
    self: MDD,
    newarcs: Iterable[MDDArc], # arcs to be added
) -> None:
    """Add arcs to the MDD, without any sanity checks."""
    for arc in newarcs:
        self.add_arc(arc)

# %% ../nbs/00_mdd.ipynb 22
@patch
def remove_arc(
    self: MDD,
    rmvarc: MDDArc, # arc to be removed
) -> None:
    """Remove an arc from the MDD, without any sanity checks."""
    self.get_node_info(rmvarc.tail).outgoing.remove(rmvarc)
    self.get_node_info(rmvarc.head).incoming.remove(rmvarc)

# %% ../nbs/00_mdd.ipynb 23
@patch
def remove_arcs(
    self: MDD,
    rmvarcs: Iterable[MDDArc], # arcs to be removed
) -> None:
    """Remove arcs from the MDD, without any sanity checks."""
    for arc in rmvarcs:
        self.remove_arc(arc)

# %% ../nbs/00_mdd.ipynb 24
@patch
def add_node(
    self: MDD,
    newnode: MDDNode, # node to be added
) -> None:
    """Add a node to the MDD, without any sanity checks.

    The node's layer should already exist in the MDD.

    NOTE: If an identical node already exists, its incoming and outgoing
    arcs will be ERASED!!!
    """
    self.nodes[newnode.layer][newnode] = MDDNodeInfo()

# %% ../nbs/00_mdd.ipynb 25
@patch
def add_nodes(
    self: MDD,
    newnodes: Iterable[MDDNode], # nodes to be added
) -> None:
    """Add nodes to the MDD, without any sanity checks."""
    for node in newnodes:
        self.add_node(node)

# %% ../nbs/00_mdd.ipynb 26
@patch
def remove_node(
    self: MDD,
    rmvnode: MDDNode, # node to be removed
) -> None:
    """Remove a node from the MDD, without any sanity checks."""
    for arc in self.get_node_info(rmvnode).incoming:
        self.get_node_info(arc.tail).outgoing.remove(arc)
    for arc in self.get_node_info(rmvnode).outgoing:
        self.get_node_info(arc.head).incoming.remove(arc)
    del self.nodes[rmvnode.layer][rmvnode]

# %% ../nbs/00_mdd.ipynb 27
@patch
def remove_nodes(
    self: MDD,
    rmvnodes: Iterable[MDDNode], # nodes to be removed
) -> None:
    """Remove nodes from the MDD, without any sanity checks."""
    for node in rmvnodes:
        self.remove_node(node)

# %% ../nbs/00_mdd.ipynb 31
def _default_awfun(w: float, ns: MDDNodeState, nt: MDDNodeState, j: int) -> float:
    """By default, do not adjust the weight of the arc."""
    return w

@patch
def merge_nodes(
    self: MDD,
    mnodes: Collection[MDDNode],
    mlayer: int,
    nsfun: Callable[[Collection[MDDNodeState], int], MDDNodeState],
    awinfun: Callable[[float, MDDNodeState, MDDNodeState, int], float] | None = None,
    awoutfun: Callable[[float, MDDNodeState, MDDNodeState, int], float] | None = None,
) -> MDDNode:
    """Merge specified nodes into a new supernode, and modify arcs appropriately.

    NOTE: All nodes to be merged must be located on the same layer.

    Parameters
    ----------
    mnodes : Collection[MDDNode]
        nodes to be merged together
    mlayer : int
        layer containing all nodes to be merged
    nsfun : Callable[[Collection[MDDNodeState], int], MDDNodeState]
        nsfun(slist,j) returns the node state resulting from merging node states in 'slist' in layer 'j'
    awinfun : Callable[[float, MDDNodeState, MDDNodeState, int], float] | None
        awinfun(w,os,ms,j) returns the adjusted weight of an arc with weight 'w', old head node state 'os', and new head node (i.e., merged supernode in layer 'j') state 'ms';
        if awfun is None (default), the original weight is used
    awoutfun : Callable[[float, MDDNodeState, MDDNodeState, int], float] | None
        awoutfun(w,os,ms,j) returns the adjusted weight of an arc with weight 'w', old tail node state 'os', and new tail node (i.e., merged supernode in layer 'j') state 'ms';
        if awoutfun is None (default), the original weight is used

    Returns
    -------
    MDDNode
        new merged supernode
    """
    if awinfun is None:
        awinfun = _default_awfun
    if awoutfun is None:
        awoutfun = _default_awfun

    # Create new supernode, and new incoming / outgoing arcs
    mState = nsfun([v.state for v in mnodes], mlayer)
    mNode = MDDNode(mlayer, mState)

    newIncoming = []
    newOutgoing = []
    for v in mnodes:
        node_info = self.get_node_info(v)
        for inarc in node_info.incoming:
            new_inarc = MDDArc(inarc.label, awinfun(inarc.weight, inarc.head.state, mState, mlayer), inarc.tail, mNode)
            newIncoming.append(new_inarc)
        for outarc in node_info.outgoing:
            new_outarc = MDDArc(outarc.label, awoutfun(outarc.weight, outarc.tail.state, mState, mlayer), mNode, outarc.head)
            newOutgoing.append(new_outarc)

    # Delete merged nodes
    for v in mnodes:
        self.remove_node(v)

    # Add supernode and its arcs to MDD
    self.add_node(mNode)
    for inarc in newIncoming:
        self.add_arc(inarc)
    for outarc in newOutgoing:
        self.add_arc(outarc)

    # Return new merged supernode
    return mNode
