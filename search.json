[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "python-mdd",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "python-mdd",
    "section": "Install",
    "text": "Install\npip install python_mdd"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "python-mdd",
    "section": "How to use",
    "text": "How to use\nThe API documentation is auto-generated by nbdev/Quarto and hosted on GitHub Pages.\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "index.html#development",
    "href": "index.html#development",
    "title": "python-mdd",
    "section": "Development",
    "text": "Development\nThis repo is set up using nbdev, a Jupyter notebook-driven software development platform especially suited to creating Python packages with extensive, high-quality documentation. Additionally, the Docker files provide a complete containerized JupyterLab environment for development.\nAt a high level, the development workflow of nbdev can be summarized as follows:\n\nDirectly edit module source code / documentation in notebook files in nbs/.\n“Restart the kernel and run all cells” to run the entire Notebook and check for errors.\nCheck the generated documentation via nbdev_preview.\nOnce you’re ready to commit changes, run the entire notebook, save, close it, then confirm via Git.\n\nYou can also manually run nbdev_prepare and pre-commit run --all-files.\n\n\nNotably, README.md and the files in python_mdd/ should NOT be manually edited; instead, they should be generated based on notebook files in nbs/.\nSee the nbdev documentation for additional details on software development using nbdev.\nTo spin up the containerized JupyterLab server, run (from the repo root)\ndocker compose up server\nTo take it down, run (from the repo root)\ndocker compose down\nSome notable quirks of this particular containerized setup:\n\npre-commit is configured to enforce type-checking and linting. In particular, .git/hooks/pre-commit is OVERWRITTEN on container start-up. If you wish to customize pre-commit (or disable it), you can do so by modifying docker/start-notebook.d/20-configure-pre-commit.sh or adding additional startup scripts.\nnbdev_preview is configured to output to 0.0.0.0:3000 (and will say so in the console output), but it’s actually outputting to localhost:3000 (from the perspective of the host machine). This is due to the command being run from within a container.\nThe outputs of Jupyter notebooks are cleaned on save via nbdev’s Jupyter hook. Note that this may not be (is usually not) immediately reflected in the JupyterLab web interface.\nOn container start-up, the repo package is installed in editable mode with the command pip install -e '.[dev]' to ensure it can be accessed from any notebook.\n\nAlternatively, any software development environment set up to work with the nbdev platform should also be sufficient.\n\nNotes on accessing host SSH credentials from within a container\nYou may want to access your host SSH credentials from within the container if you are using pre-commit with the containerized environment. Unfortunately this can be tricky to set up (especially on Windows), and the details are far beyond the scope of this README.\nThat said, one relatively straightforward method is to specify a private compose.override.yaml file to mount the necessary SSH files. The following links may provide some guidance on specifics:\n\nhttps://blog.gabrielmajeri.ro/2022/01/21/how-to-share-ssh-credentials-between-windows-and-wsl-2.html\nhttps://skyraptor.eu/blog/seamless-integration-using-windows-ssh-keys-and-ssh-agent-in-wsl2\nhttps://docs.docker.com/desktop/networking/#ssh-agent-forwarding\nhttps://code.visualstudio.com/remote/advancedcontainers/sharing-git-credentials"
  },
  {
    "objectID": "mdd.html",
    "href": "mdd.html",
    "title": "mdd",
    "section": "",
    "text": "source\n\n\n\n MDDNode (layer:int, state:collections.abc.Hashable)\n\n*MDDNode represents a single node in the MDD.\nAn MDDNode is uniquely identified by its layer and state. The (node) state must be a collections.abc.Hashable object.*\n\n\n\n\nType\nDetails\n\n\n\n\nlayer\nint\nlayer the node is in\n\n\nstate\nHashable\nstate associated with node\n\n\n\nMDDNode represents a node in the decision diagram. It is uniquely identified by which layer the node is located in, and the node’s state. The state should be hashable to ensure we can quickly identify when two nodes in the same layer are “equivalent”.\n\nn1 = MDDNode(0, (1, 2, 3))\nn2 = MDDNode(1, (1, 3))\nn1_copy = MDDNode(0, (1, 2, 3))\nprint(f\"n1 = {n1}\\nn2 = {n2}\\nn1_copy = {n1_copy}\")\nprint(f\"`n1_copy is n1` -&gt; {n1_copy is n1}\")\nprint(f\"`n1_copy == n1` -&gt; {n1_copy == n1}\")\n\nn1 = N_0((1, 2, 3))\nn2 = N_1((1, 3))\nn1_copy = N_0((1, 2, 3))\n`n1_copy is n1` -&gt; False\n`n1_copy == n1` -&gt; True\n\n\n\nsource\n\n\n\n\n MDDArc (label:collections.abc.Hashable, tail:__main__.MDDNode,\n         head:__main__.MDDNode)\n\n*MDDArc represents a single arc in the MDD.\nAn MDDArc is uniquely identified by its head node, tail node, and label. The (arc) label must be a collections.abc.Hashable object.*\n\n\n\n\nType\nDetails\n\n\n\n\nlabel\nHashable\nlabel of arc (e.g., assigned value)\n\n\ntail\nMDDNode\ntail/source node\n\n\nhead\nMDDNode\nhead/destination node\n\n\n\nMDDArc represents an arc in the decision diagram. It is uniquely identified by the combination of its tail node, head node, and label.\n\na1_2 = MDDArc(2, n1, n2)\nprint(f\"a1_2 = {a1_2}\")\n\na1_2 = A(2:N_0((1, 2, 3)),N_1((1, 3)))\n\n\n\nsource\n\n\n\n\n MDDNodeData (incoming:list[__main__.MDDArc]=&lt;factory&gt;,\n              outgoing:list[__main__.MDDArc]=&lt;factory&gt;)\n\nMDDNodeData represents information associated with an MDDNode.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nincoming\nlist\n\nlist of incoming arcs (default: [])\n\n\noutgoing\nlist\n\nlist of outgoing arcs (default: [])\n\n\n\nMDDNodeData represents information associated with a node in the decision diagram, in particular its incoming and outgoing arcs.\n\nnode_data = MDDNodeData(incoming=[], outgoing=[a1_2])\nprint(f\"node_data = {node_data}\")\n\nnode_data = &lt;in=[], out=[A(2:N_0((1, 2, 3)),N_1((1, 3)))]&gt;\n\n\n\nsource\n\n\n\n\n MDDArcData (weight:float=0.0)\n\nMDDArcData represents information associated with an MDDArc.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nweight\nfloat\n0.0\nweight of arc (default: 0.0)\n\n\n\n\nsource\n\n\n\n\n MDD (name:str='mdd',\n      nodes:list[dict[__main__.MDDNode,__main__.MDDNodeData]]=&lt;factory&gt;,\n      arcs:dict[__main__.MDDArc,__main__.MDDArcData]=&lt;factory&gt;)\n\nMDD represents a multivalued decision diagram.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nmdd\nname of MDD (default: ‘mdd’)\n\n\nnodes\nlist\n\nnodes of MDD (default: [])\n\n\narcs\ndict\n\narcs of MDD (default: dict())\n\n\n\nThe MDD is the core object of this module, representing a multivalued decision diagram. An MDD starts out empty, with 0 node layers and -1 arc layers. In addition to basic getter methods, it has a __str__ method for pretty printing its current state.\n\nmdd0 = MDD()\nprint(f\"mdd0 = {mdd0}\")\nprint(f\"num_node_layers = {mdd0.num_node_layers}\")\nprint(f\"num_arc_layers = {mdd0.num_arc_layers}\")\n\nmdd0 = == MDD (mdd, -1 layers) ==\n# Nodes\n# (Outgoing) Arcs\n\nnum_node_layers = 0\nnum_arc_layers = -1",
    "crumbs": [
      "mdd"
    ]
  },
  {
    "objectID": "mdd.html#classes",
    "href": "mdd.html#classes",
    "title": "mdd",
    "section": "",
    "text": "source\n\n\n\n MDDNode (layer:int, state:collections.abc.Hashable)\n\n*MDDNode represents a single node in the MDD.\nAn MDDNode is uniquely identified by its layer and state. The (node) state must be a collections.abc.Hashable object.*\n\n\n\n\nType\nDetails\n\n\n\n\nlayer\nint\nlayer the node is in\n\n\nstate\nHashable\nstate associated with node\n\n\n\nMDDNode represents a node in the decision diagram. It is uniquely identified by which layer the node is located in, and the node’s state. The state should be hashable to ensure we can quickly identify when two nodes in the same layer are “equivalent”.\n\nn1 = MDDNode(0, (1, 2, 3))\nn2 = MDDNode(1, (1, 3))\nn1_copy = MDDNode(0, (1, 2, 3))\nprint(f\"n1 = {n1}\\nn2 = {n2}\\nn1_copy = {n1_copy}\")\nprint(f\"`n1_copy is n1` -&gt; {n1_copy is n1}\")\nprint(f\"`n1_copy == n1` -&gt; {n1_copy == n1}\")\n\nn1 = N_0((1, 2, 3))\nn2 = N_1((1, 3))\nn1_copy = N_0((1, 2, 3))\n`n1_copy is n1` -&gt; False\n`n1_copy == n1` -&gt; True\n\n\n\nsource\n\n\n\n\n MDDArc (label:collections.abc.Hashable, tail:__main__.MDDNode,\n         head:__main__.MDDNode)\n\n*MDDArc represents a single arc in the MDD.\nAn MDDArc is uniquely identified by its head node, tail node, and label. The (arc) label must be a collections.abc.Hashable object.*\n\n\n\n\nType\nDetails\n\n\n\n\nlabel\nHashable\nlabel of arc (e.g., assigned value)\n\n\ntail\nMDDNode\ntail/source node\n\n\nhead\nMDDNode\nhead/destination node\n\n\n\nMDDArc represents an arc in the decision diagram. It is uniquely identified by the combination of its tail node, head node, and label.\n\na1_2 = MDDArc(2, n1, n2)\nprint(f\"a1_2 = {a1_2}\")\n\na1_2 = A(2:N_0((1, 2, 3)),N_1((1, 3)))\n\n\n\nsource\n\n\n\n\n MDDNodeData (incoming:list[__main__.MDDArc]=&lt;factory&gt;,\n              outgoing:list[__main__.MDDArc]=&lt;factory&gt;)\n\nMDDNodeData represents information associated with an MDDNode.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nincoming\nlist\n\nlist of incoming arcs (default: [])\n\n\noutgoing\nlist\n\nlist of outgoing arcs (default: [])\n\n\n\nMDDNodeData represents information associated with a node in the decision diagram, in particular its incoming and outgoing arcs.\n\nnode_data = MDDNodeData(incoming=[], outgoing=[a1_2])\nprint(f\"node_data = {node_data}\")\n\nnode_data = &lt;in=[], out=[A(2:N_0((1, 2, 3)),N_1((1, 3)))]&gt;\n\n\n\nsource\n\n\n\n\n MDDArcData (weight:float=0.0)\n\nMDDArcData represents information associated with an MDDArc.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nweight\nfloat\n0.0\nweight of arc (default: 0.0)\n\n\n\n\nsource\n\n\n\n\n MDD (name:str='mdd',\n      nodes:list[dict[__main__.MDDNode,__main__.MDDNodeData]]=&lt;factory&gt;,\n      arcs:dict[__main__.MDDArc,__main__.MDDArcData]=&lt;factory&gt;)\n\nMDD represents a multivalued decision diagram.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nmdd\nname of MDD (default: ‘mdd’)\n\n\nnodes\nlist\n\nnodes of MDD (default: [])\n\n\narcs\ndict\n\narcs of MDD (default: dict())\n\n\n\nThe MDD is the core object of this module, representing a multivalued decision diagram. An MDD starts out empty, with 0 node layers and -1 arc layers. In addition to basic getter methods, it has a __str__ method for pretty printing its current state.\n\nmdd0 = MDD()\nprint(f\"mdd0 = {mdd0}\")\nprint(f\"num_node_layers = {mdd0.num_node_layers}\")\nprint(f\"num_arc_layers = {mdd0.num_arc_layers}\")\n\nmdd0 = == MDD (mdd, -1 layers) ==\n# Nodes\n# (Outgoing) Arcs\n\nnum_node_layers = 0\nnum_arc_layers = -1",
    "crumbs": [
      "mdd"
    ]
  },
  {
    "objectID": "mdd.html#mdd-getter-methods",
    "href": "mdd.html#mdd-getter-methods",
    "title": "mdd",
    "section": "MDD: Getter methods",
    "text": "MDD: Getter methods\n\nsource\n\nMDD.num_node_layers\n\n MDD.num_node_layers ()\n\n*Number of node layers; equal to number of ‘variables’ + 1.\nClass property: int*\n\nsource\n\n\nMDD.num_arc_layers\n\n MDD.num_arc_layers ()\n\n*Number of arc layers; equal to number of ‘variables’.\nClass property: int*\n\nsource\n\n\nMDD.width_list\n\n MDD.width_list ()\n\n*Number of nodes in each layer.\nClass property: list[int]*\n\nsource\n\n\nMDD.max_width\n\n MDD.max_width ()\n\n*Maximum number of nodes in a single node layer.\nClass property: int*\n\nsource\n\n\nMDD.all_nodes\n\n MDD.all_nodes ()\n\n*Iterate over all nodes in the MDD.\nReturns: collections.abc.Iterator[MDDNode]*\n\nsource\n\n\nMDD.all_nodeitems_in_layer\n\n MDD.all_nodeitems_in_layer (layer:int)\n\nA view of all nodes and their associated data in a layer.\n\n\n\n\nType\nDetails\n\n\n\n\nlayer\nint\nindex of layer\n\n\nReturns\nItemsView\ncollections.abc.ItemsView[MDDNode, MDDNodeData]\n\n\n\n\nsource\n\n\nMDD.allnodes_in_layer\n\n MDD.allnodes_in_layer (layer:int)\n\nReturn a view of all nodes in a layer.\n\n\n\n\nType\nDetails\n\n\n\n\nlayer\nint\nindex of layer\n\n\nReturns\nKeysView\ncollections.abc.KeysView[MDDNode]\n\n\n\n\nsource\n\n\nMDD.all_outgoing_arcs\n\n MDD.all_outgoing_arcs ()\n\n*Iterate over all outgoing arcs in the MDD.\nReturns: collections.abc.Iterator[MDDArc]*\n\nsource\n\n\nMDD.all_incoming_arcs\n\n MDD.all_incoming_arcs ()\n\n*Iterate over all incoming arcs in the MDD.\nReturns: collections.abc.Iterator[MDDArc]*\n\nsource\n\n\nMDD.__str__\n\n MDD.__str__ (show_long:bool=False, show_incoming:bool=False)\n\nReturn a (human-readable) string representation of the MDD.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nshow_long\nbool\nFalse\nuse more vertical space (default: False)\n\n\nshow_incoming\nbool\nFalse\nshow incoming arcs (default: False)\n\n\nReturns\nstr",
    "crumbs": [
      "mdd"
    ]
  },
  {
    "objectID": "mdd.html#mdd-basic-operations",
    "href": "mdd.html#mdd-basic-operations",
    "title": "mdd",
    "section": "MDD: Basic operations",
    "text": "MDD: Basic operations\n\nsource\n\nMDD.clear\n\n MDD.clear ()\n\n*Reset the MDD.\nReturns: None*\n\nsource\n\n\nMDD.append_new_layers\n\n MDD.append_new_layers (n:int=1)\n\nAppend new layers to the MDD.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nn\nint\n1\nnumber of layers to append\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nMDD.get_node_data\n\n MDD.get_node_data (node:__main__.MDDNode)\n\n*Get MDDNodeData corresponding to node.\nNote this function can NOT be used to populate the underlying dictionary; it can only be used to reference the object.\nIn general, you should use MDD.all_nodeitems_in_layer if you want to update node data in a systematic manner. The author recommends only using this function if MDD.all_nodeitems_in_layer cannot be used.*\n\n\n\n\nType\nDetails\n\n\n\n\nnode\nMDDNode\nnode in MDD\n\n\nReturns\nMDDNodeData\n\n\n\n\n\nsource\n\n\nMDD.add_arc\n\n MDD.add_arc (newarc:__main__.MDDArc, newarc_data:__main__.MDDArcData)\n\n*Add an arc to the MDD, without any sanity checks.\nThe head and tail nodes of the arc should already exist in the MDD.*\n\n\n\n\nType\nDetails\n\n\n\n\nnewarc\nMDDArc\narc to be added\n\n\nnewarc_data\nMDDArcData\ndata for arc to be added\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.add_arcs\n\n MDD.add_arcs\n               (newarcs:collections.abc.Mapping[__main__.MDDArc,__main__.M\n               DDArcData])\n\nAdd arcs to the MDD, without any sanity checks.\n\n\n\n\nType\nDetails\n\n\n\n\nnewarcs\nMapping\narcs and their data to be added\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.remove_arc\n\n MDD.remove_arc (rmvarc:__main__.MDDArc)\n\nRemove an arc from the MDD, without any sanity checks.\n\n\n\n\nType\nDetails\n\n\n\n\nrmvarc\nMDDArc\narc to be removed\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.remove_arcs\n\n MDD.remove_arcs (rmvarcs:collections.abc.Iterable[__main__.MDDArc])\n\nRemove arcs from the MDD, without any sanity checks.\n\n\n\n\nType\nDetails\n\n\n\n\nrmvarcs\nIterable\narcs to be removed\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.add_node\n\n MDD.add_node (newnode:__main__.MDDNode)\n\n*Add a node to the MDD, without any sanity checks.\nThe node’s layer should already exist in the MDD.\nNOTE: If an identical node already exists, its incoming and outgoing arcs will be ERASED!!!*\n\n\n\n\nType\nDetails\n\n\n\n\nnewnode\nMDDNode\nnode to be added\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.add_nodes\n\n MDD.add_nodes (newnodes:collections.abc.Iterable[__main__.MDDNode])\n\nAdd nodes to the MDD, without any sanity checks.\n\n\n\n\nType\nDetails\n\n\n\n\nnewnodes\nIterable\nnodes to be added\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.remove_node\n\n MDD.remove_node (rmvnode:__main__.MDDNode)\n\nRemove a node from the MDD, without any sanity checks.\n\n\n\n\nType\nDetails\n\n\n\n\nrmvnode\nMDDNode\nnode to be removed\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nMDD.remove_nodes\n\n MDD.remove_nodes (rmvnodes:collections.abc.Iterable[__main__.MDDNode])\n\nRemove nodes from the MDD, without any sanity checks.\n\n\n\n\nType\nDetails\n\n\n\n\nrmvnodes\nIterable\nnodes to be removed\n\n\nReturns\nNone\n\n\n\n\nTo populate the MDD, you must first add the necessary layers, then the nodes and arcs. Note that the basic functions do not perform any sanity checks, so it’s the programmer’s responsibility to avoid errors.\n\nmdd0.append_new_layers(n=2)\nmdd0.add_nodes([n1, n2])\nmdd0.add_arc(a1_2, MDDArcData(0))\nprint(f\"mdd0 = {mdd0}\")\n\nmdd0 = == MDD (mdd, 1 layers) ==\n# Nodes\nL0: N_0((1, 2, 3))\nL1: N_1((1, 3))\n# (Outgoing) Arcs\nA(2:N_0((1, 2, 3)),N_1((1, 3))):&lt;0&gt;\n\n\n\nsource\n\n\nMDD.merge_nodes\n\n MDD.merge_nodes (mnodes:collections.abc.Collection[__main__.MDDNode],\n                  mlayer:int, nsfun:collections.abc.Callable[[collections.\n                  abc.Collection[collections.abc.Hashable],int],collection\n                  s.abc.Hashable], adinfun:Optional[collections.abc.Callab\n                  le[[__main__.MDDArcData,collections.abc.Hashable,collect\n                  ions.abc.Hashable,int],__main__.MDDArcData]]=None, adout\n                  fun:Optional[collections.abc.Callable[[__main__.MDDArcDa\n                  ta,collections.abc.Hashable,collections.abc.Hashable,int\n                  ],__main__.MDDArcData]]=None)\n\n*Merge specified nodes into a new supernode, and modify arcs appropriately.\nNOTE: All nodes to be merged must be located on the same layer.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmnodes\nCollection\n\nnodes to be merged together\n\n\nmlayer\nint\n\nlayer containing all nodes to be merged\n\n\nnsfun\nCallable\n\nfunction that determines the node state of the new merged supernode\n\n\nadinfun\nOptional\nNone\nfunction that determines the arc data of all arcs incoming to the new merged supernode;if adinfun is None (default), the original arc data is used\n\n\nadoutfun\nOptional\nNone\nfunction that determines the arc data of all arcs outgoing from the new merged supernode;if adoutfun is None (default), the original arc data is used\n\n\nReturns\nMDDNode\n\nnew merged supernode\n\n\n\nThe behavior of MDD.merge_nodes can be customized by specifying how to get the node state and arc data associated with the new merged supernode.\n\nnsfun(slist, j) returns the node state resulting from merging node states in ‘slist’ in layer ‘j’\n\nParameter types\n\nslist: collections.abc.Collection[MDDNodeState])\nj: int\n\nReturn type: MDDNodeState)\n\nadinfun(d, os, ms, j) returns the adjusted data of an arc incoming into node layer ‘j’ with original arc data ‘d’, original head node state ‘os’, and new head node state ‘ms’ (i.e., node state of the merged supernode)\n\nParameter types\n\nd: MDDArcData\nos: MDDNodeState\nms: MDDNodeState\nj: int\n\nReturn type: MDDArcData\n\nadoutfun(d, os, ms, j) returns the adjusted data of an arc outgoing from node layer ‘j’ with original arc data ‘a’, original tail node state ‘os’, and new tail node state ‘ms’ (i.e., node state of the merged supernode)\n\nParameter types\n\nd: MDDArcData\nos: MDDNodeState\nms: MDDNodeState\nj: int\n\nReturn type: MDDArcData\n\n\nYou can merge nodes in an MDD to reduce its size. Depending on the merging rule, this will typically result in an relaxation or restriction of the original MDD. The basic merge_nodes() function is configured based on node state functions, and is quite flexible. However, it can only merge nodes on the same layer.\n\ndef test_merge_nodes() -&gt; None:\n    mymdd = MDD()\n    mymdd.append_new_layers()\n    n0 = MDDNode(0, 0)\n    mymdd.add_node(n0)\n    mymdd.append_new_layers()\n    n1 = MDDNode(1, 1)\n    n2 = MDDNode(1, 2)\n    n3 = MDDNode(1, 3)\n    mymdd.add_nodes([n1, n2, n3])\n    mymdd.append_new_layers()\n    n4 = MDDNode(2, 4)\n    mymdd.add_node(n4)\n    all_arcs = {\n        MDDArc(1, n0, n1): MDDArcData(1),\n        MDDArc(2, n0, n2): MDDArcData(2),\n        MDDArc(3, n0, n3): MDDArcData(3),\n        MDDArc(14, n1, n4): MDDArcData(-1),\n        MDDArc(24, n2, n4): MDDArcData(-2),\n        MDDArc(34, n3, n4): MDDArcData(-3),\n    }\n    mymdd.add_arcs(all_arcs)\n    print(mymdd)\n    print()\n    mymdd.merge_nodes([n1, n2, n3], 1, lambda ns, l: max(s for s in ns))\n    print(mymdd)\n    assert len(list(mymdd.all_nodes())) == 3\n    assert {a.label for a in mymdd.all_outgoing_arcs()} == {1, 2, 3, 14, 24, 34}\n\ntest_merge_nodes()\n\n== MDD (mdd, 2 layers) ==\n# Nodes\nL0: N_0(0)\nL1: N_1(1), N_1(2), N_1(3)\nL2: N_2(4)\n# (Outgoing) Arcs\nA(1:N_0(0),N_1(1)):&lt;1&gt;, A(2:N_0(0),N_1(2)):&lt;2&gt;, A(3:N_0(0),N_1(3)):&lt;3&gt;, A(14:N_1(1),N_2(4)):&lt;-1&gt;, A(24:N_1(2),N_2(4)):&lt;-2&gt;, A(34:N_1(3),N_2(4)):&lt;-3&gt;\n\n== MDD (mdd, 2 layers) ==\n# Nodes\nL0: N_0(0)\nL1: N_1(3)\nL2: N_2(4)\n# (Outgoing) Arcs\nA(1:N_0(0),N_1(3)):&lt;1&gt;, A(2:N_0(0),N_1(3)):&lt;2&gt;, A(3:N_0(0),N_1(3)):&lt;3&gt;, A(14:N_1(3),N_2(4)):&lt;-1&gt;, A(24:N_1(3),N_2(4)):&lt;-2&gt;, A(34:N_1(3),N_2(4)):&lt;-3&gt;\n.                                                                                            [100%]\n\n\nWhile MDD does not explicitly forbid “skip arcs” (arcs that connect nodes in non-adjacent layers), most functionality is designed assuming there are no skip arcs.\n\ndef test_merge_skip_arcs_fails() -&gt; None:\n    mymdd = MDD()\n    mymdd.append_new_layers(4)\n    n0 = MDDNode(0, 0)\n    n1 = MDDNode(1, 1)\n    n2 = MDDNode(2, 2)\n    n3 = MDDNode(3, 3)\n    mymdd.add_nodes([n0, n1, n2, n3])\n    mymdd.add_arcs({MDDArc(1, n0, n1): MDDArcData(1), MDDArc(2, n1, n2): MDDArcData(2), MDDArc(2, n2, n3): MDDArcData(2)})\n    print(mymdd)\n    print()\n    with pytest.raises(KeyError):\n        mymdd.merge_nodes([n1, n2], 1, lambda ns, l: max(ns))\n        print(mymdd)\n\ntest_merge_skip_arcs_fails()\n\n== MDD (mdd, 3 layers) ==\n# Nodes\nL0: N_0(0)\nL1: N_1(1)\nL2: N_2(2)\nL3: N_3(3)\n# (Outgoing) Arcs\nA(1:N_0(0),N_1(1)):&lt;1&gt;, A(2:N_1(1),N_2(2)):&lt;2&gt;, A(2:N_2(2),N_3(3)):&lt;2&gt;\n\n.                                                                                            [100%]\n\n\n\ndef test_merge_skip_arcs_works_sometimes() -&gt; None:\n    mymdd = MDD()\n    mymdd.append_new_layers(4)\n    n0 = MDDNode(0, 0)\n    n1 = MDDNode(1, 1)\n    n2 = MDDNode(2, 2)\n    n3 = MDDNode(3, 3)\n    mymdd.add_nodes([n0, n1, n2, n3])\n    mymdd.add_arcs({\n        MDDArc(\"a\", n0, n1): MDDArcData(1),\n        MDDArc(\"b\", n0, n2): MDDArcData(2),\n        MDDArc(\"c\", n1, n3): MDDArcData(2),\n        MDDArc(\"d\", n2, n3): MDDArcData(1),\n    })\n    print(mymdd)\n    print()\n    mymdd.merge_nodes([n1, n2], 2, lambda ns, l: max(ns))\n    print(mymdd)\n    assert len(list(mymdd.allnodes_in_layer(1))) == 0\n    assert {a.label for a in mymdd.all_outgoing_arcs()} == {\"a\", \"b\", \"c\", \"d\"}\n\ntest_merge_skip_arcs_works_sometimes()\n\n== MDD (mdd, 3 layers) ==\n# Nodes\nL0: N_0(0)\nL1: N_1(1)\nL2: N_2(2)\nL3: N_3(3)\n# (Outgoing) Arcs\nA(a:N_0(0),N_1(1)):&lt;1&gt;, A(b:N_0(0),N_2(2)):&lt;2&gt;, A(c:N_1(1),N_3(3)):&lt;2&gt;, A(d:N_2(2),N_3(3)):&lt;1&gt;\n\n== MDD (mdd, 3 layers) ==\n# Nodes\nL0: N_0(0)\nL1: \nL2: N_2(2)\nL3: N_3(3)\n# (Outgoing) Arcs\nA(a:N_0(0),N_2(2)):&lt;1&gt;, A(b:N_0(0),N_2(2)):&lt;2&gt;, A(c:N_2(2),N_3(3)):&lt;2&gt;, A(d:N_2(2),N_3(3)):&lt;1&gt;\n.                                                                                            [100%]",
    "crumbs": [
      "mdd"
    ]
  },
  {
    "objectID": "compile.html",
    "href": "compile.html",
    "title": "compile",
    "section": "",
    "text": "source\n\ncompile_top_down\n\n compile_top_down (num_layers:int,\n                   domain_function:collections.abc.Callable[[int],list[int\n                   ]], transition_function:collections.abc.Callable[[colle\n                   ctions.abc.Hashable,int,int],collections.abc.Hashable],\n                   arc_data_function:collections.abc.Callable[[collections\n                   .abc.Hashable,int,int,collections.abc.Hashable],python_\n                   mdd.mdd.MDDArcData],\n                   root_state:collections.abc.Hashable, is_feasible:collec\n                   tions.abc.Callable[[collections.abc.Hashable,int],bool]\n                   , max_width:Optional[collections.abc.Callable[[int],flo\n                   at]]=None, merge_function:Optional[collections.abc.Call\n                   able[[collections.abc.Collection[collections.abc.Hashab\n                   le],int],collections.abc.Hashable]]=None, arcdata_funct\n                   ion:Optional[collections.abc.Callable[[python_mdd.mdd.M\n                   DDArcData,collections.abc.Hashable,collections.abc.Hash\n                   able,int],python_mdd.mdd.MDDArcData]]=None, node_select\n                   ion_function:Optional[collections.abc.Callable[[collect\n                   ions.abc.Sequence[python_mdd.mdd.MDDNode],int],list[pyt\n                   hon_mdd.mdd.MDDNode]]]=None, name:str='mdd')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnum_layers\nint\n\nnumber of (arc) layers, i.e., variables\n\n\ndomain_function\nCallable\n\nfunction specifying the domain of each layer\n\n\ntransition_function\nCallable\n\nfunction specifying the state transitions\n\n\narc_data_function\nCallable\n\nfunction specifying arc data\n\n\nroot_state\nHashable\n\nstate of the root node\n\n\nis_feasible\nCallable\n\nfunction that determines whether a node state is feasible\n\n\nmax_width\nOptional\nNone\nfunction specifying the maximum width of each layer\n\n\nmerge_function\nOptional\nNone\nfunction that determines how to merge node states\n\n\narcdata_function\nOptional\nNone\nfunction specifying the arc data\n\n\nnode_selection_function\nOptional\nNone\nfunction specifying nodes to select for merge / removal\n\n\nname\nstr\nmdd\nname of MDD\n\n\nReturns\nMDD\n\nCompiled decision diagram\n\n\n\nWIP: Some examples\n\ndef test_compile_knapsack() -&gt; None:\n    num_vars = 4\n    capacity = 6\n    profit = [8, 7, 6, 14]\n    weight = [3, 3, 4, 6]\n\n    domain = lambda i: (0, 1)\n    root_state = capacity\n    tr_func = lambda s,d,i: s - d * weight[i]\n    ad_func = lambda s,d,i,ns: MDDArcData(weight=d * profit[i])\n    is_feas = lambda s,i: s &gt;= 0\n    merge_func = lambda slist,i: min(slist)\n    name = \"knapsack\"\n\n    mdd = compile_top_down(\n        num_layers=num_vars,\n        domain_function=domain,\n        transition_function=tr_func,\n        arc_data_function=ad_func,\n        root_state=root_state,\n        is_feasible=is_feas,\n        name=name,\n    )\n\n.                                                                                            [100%]",
    "crumbs": [
      "compile"
    ]
  }
]